//마우스의 이동 방법
enum {
	GO18CM, GO13CM, GO9CM, LT45, RT45, LT90, RT90, LT180, RT180,
	LSTURN, RSTURN, GOBLOCK
};

//턴 가중치를 정의
//턴이 직진보다 느리기 때문에
//일정한 가중치를 주는 것이 합리적이다.
enum {
        WFRONT =1, //전진시의 가중치
        WPATH45=1, //45도 주행시의 가중치
        WTURN45=2, //45도 턴시의 가중치
        WTURN90=2, //90도 턴시의 가중치
        WTURN135=3, //135도 턴시의 가중치
        WTURN180=3 //180도 턴시의 가중치
};

enum {

        //짝수 위치에서 이동시의 위치의 변화분
        eN      = 2, //북쪽으로 이동시
        eNE = 35,    //북동쪽으로,,
        eE  = 0,     //움직일 수 없는 방향
        eSE = 33,    //남동
        eS  = -2,    //남
        eSW = -1,    //남서
        eW  = 0,     //움직일 수 없는 방향
        eNW = 1,     //북서

        //홀수 위치에서 이동시의 위치의 변화분
	oN	= 0, 	//no move
	oNE	= 1,
	oE	= 34,
	oSE	= -1,
	oS	= 0, 	//no move
	oSW	= -35,
	oW	= -34,
	oNW	= -33,

        //방향 값
        dN      = 0, //북
        dNE = 2,     //북동
        dE      = 4, //동
        dSE = 6,     //남동
        dS      = 8, //남
        dSW = 10,    //남서
        dW      = 12,//서
        dNW = 14,    //북서

        //턴 값
        t0       = 0, //직진(턴이 없음)
        tR45 = 2,     //오른쪽 45도
        tR90 = 4,     //오른쪽 90도
        tR135= 6,     //오른쪽 135도
        t180 = 8,     //180도
        tL135= 10,    //왼쪽 135도
        tL90 = 12,    //왼쪽 90도
        tL45 = 14     //왼쪽 45도
};

//SIMLULATION 객체의 정의
//MIRO, MOUSE를 다중 상속 받은 객체이다.
class SIMULATION : public MIRO, public MOUSE {

protected:
        int mpos, mdir; //실제 마우스의 위치, 방향

        int buffer[4][1024];  //알고리즘 연산시의 가상마우스를 저장하는 버퍼
        int bp[5]; //각 버퍼의 (최상위+1)을 가리기는 버퍼 포인터
        int tracebuf[1024]; //경로 추적시의 경로 정보를 저장하는 버퍼
        int *tracer; //경로 추적시의 포인터
        int target; //마우스의 주행 목표점,
                    //즉 마우스는 이 점을 향해 주행한다.
        int walldetline; //벽의 판별선
                         //walldetline=NO_WALL 모르는 벽은 있는 것으로 간주
                         //walldetline=XX_WALL 모르는 벽은 없는 것으로 간주

        int goal; //미로에서의 목표점

public:
        SIMULATION();  //생성자
        ~SIMULATION(); //파괴자

        //미로의 위치를 설정
	void initwindow(int w_x, int w_y, int b_w, int w_w);

        //주행시의 초기화 작업
	void initrunning(void);

        //시뮬레이션 맵을 초기화
	void clearsimmap(void);

        //목표를 미로가운데의 목표로 설정
	void set_to_goal(int _walldetline);

        //목표를 시작점으로 설정
	void set_to_home(int _walldetline);

        //미로가운데운데의 4벽 중의 하나로 설정
        //목표점을 찾은 후에는 4벽 가운데 가장 좋은
        //점을 목표점으로 설정
	void setgoal(int _goal);

        //가상마우스를 퍼뜨리기 전의 초기화 작업
	void initspread(void);

        //bf의 버퍼에서 가상마우스를 퍼뜨림
        //bf=0, 1, 2, 3 : 즉, 4개의 버퍼 가운데
        //하나에서 가상마우스를 퍼뜨림
	void spread(int bf);

        //최단거리 지도를 그림
	void makeshortmap(void);
        //최단거리 경로를 추젖ㄱ
	void tracepath(void);

        //pos위치를 dir방향으로 이동
	void moveposition(int &pos, int dir);

        //왼쪽으로 스무드턴
	void lsturnning(void);

        //오른쪽으로 스무드턴
	void rsturnning(void);

        //연산자 오버로딩을 통해 쉽게 마우스
        //이동을 제어
        //EX> gsdii << GO18CM << LT45;
	SIMULATION &SIMULATION::operator<<(int cmd);

        //목표점에 도달하였는지를 체크
	int chktarget(void);

        //마우스 위치에서 앞쪽 벽의 위치를 얻음
	int get_fw_pos(void);

        //마우스 위치에서 왼쪽 벽의 위치를 얻음
	int get_lw_pos(void);

        //마우스 위치에서 오른쪽 벽의 위치를 얻음
        int get_rw_pos(void);

        //벽을 판별한다.
        //실제 마우스의 벽을 센서로 판별하는 루틴과 동일.
        //시뮬레이션에서는 시뮬레이션 map(simmap)의
        //벽정보를 마우스가 판변한 벽을 저장한 map(wallmap)
        //으로 읽어들인다.
	void detectwall(void);

        //목표점을 향해 주행할 때, 현재 마우스가 이동해야
        //할 방향을 얻는다.
	int getcommand(void);

        //목표점 가장자리에 도착하였는지 체크하여
        //목표점 가장자리 벽정보를 갱신한다.
	void chkgoalborder(void);

        //가장좋은 목표점을 설정한다.
	void setbestgoal(void);

        //마우스의 위치, 방향을 화면에 출력
	void putposition(int color);

        //기본 화면 메세지를 화면에 출력
	void titlemassage(void);

        //메세지 출력함수
	void putmassage(int ln, char *str);

        //주행모드를 화면에 출력한다.
	void putracemode(int racing, int color);
};

