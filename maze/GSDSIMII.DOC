//=====================================
//
//  저씨더 II 시뮬레이션 프로그램 V2.0
//
//         메인 루틴 1997.1.6
//  호서대학 하이텍 연구실 '94 김현준
//=====================================

#include <iostream.h>
#include <dos.h>
#include <conio.h>
#include <process.h>
#include <graphics.h>
#include "graphii.h"
#include "simul.h"

//객체 GSDII를 생성한다.
SIMULATION GSDII;

void running()
{
        //주행 모드를 가지고 있는 변수
        // 짝수: 목표점으로 주행(가운데 4블록)
        // 홀수: 출발점으로 되돌아 옴
        // 0, 1: 1차 주행; 2, 3: 2차 주행;........
	int racemode=0;

        //주행을 위한 초기화
        //화면을 다시 디스플레이, 마우스를 원점으로
	GSDII.initrunning();

        //주행 속도를 설정
	GSDII.setspeed(10);

        //초기 목표점을 설정
        GSDII.setgoal(289);

        //모르는 벽을 있는 것으로 간주할 지
        //없는 것으로 간주할 것인지를 설정
        //현재는 없는 것으로 간주함
	GSDII.set_to_goal(XX_WALL);

        //주행 모드를 화면에 표시함
	GSDII.putracemode(racemode, 0xc);

        //마우스를 반블록 전진하여
        //벽위치에 맞춘다.
	GSDII << GO9CM;

	while(1) {

                //'ESC' 키가 눌리면 주행을 멈춘다.
		if(kbhit()) {
			if(getch()==27) return;
		}

                //벽 판별
		GSDII.detectwall();

                //최단 경로를 연산한다.
		GSDII.tracepath();

                //주행 방향을 얻어서 그 방향으로 주행한다.
		switch(GSDII.getcommand()) {
			case t0:
                                GSDII << GO18CM; //전진
			break;
			case tL45:
                                GSDII << LSTURN; //왼쪽으로 스무드 턴
			break;
			case tR45:
                                GSDII << RSTURN; //오른쪽으로 스무드 턴
			break;
			default:
                                GSDII << GO9CM << LT180 << GO9CM; //뒤로 턴
			break;
		}

                //목표점에 도달하였는지를 검사
		if(GSDII.chktarget()) {

                        //반블록 더 움직여서 180도 회전 후 정지한다.
                        //블록의 가운데를 맞추어서 정지
                        //저씨더의 경우 벽의 위치를 기준으로 알고리즘
                        //연산을 하기 때문에 목표점에 도착하였을 경우
                        //벽의 위치에 도달하기 때문이다.
			GSDII << GO9CM << LT180;

                        //2초 지연
			delay(2000);

                        //주행모드를 화면에서 지운다.
			GSDII.putracemode(racemode, 0);

                        //주행모드를 1증가
			racemode++;
                        //주행모드를 화면에 다시 출력
			GSDII.putracemode(racemode, 0xc);

                        //7차주행이 넘어가면 주행을 정지
			if(racemode==14) break;

                        //주행모드에 따라서 골로 갈지, 시작점으로 갈지를
                        //설정한다.
			if(racemode&1) GSDII.set_to_home(XX_WALL);
				else GSDII.set_to_goal(NO_WALL);


                        //다시 반블록 전진하여 벽의 위치에 맞춘다.
			GSDII << GO9CM;

		}

                //1차주행에서 목표로 주행할 경우에만 목표점 가장자리에
                //도달여부를 체크
		if(racemode==0) GSDII.chkgoalborder();
	}
}

//맵 파일을 로드한다.
void loadfile()
{
        //파일 이름을 입력받는 변수
	char fname[20];

        //그래픽을 닫음. 즉, 텍스트모드로 빠진다.
	closegr();

	cout << "\n\n Type filename: ";
        cin >> fname; //파일 이름을 입력받는다.

        initgr(); // 다시 그래픽을 초기화한다.

        GSDII.clearsimmap(); //시뮬레이션 맵을 초기화한다.
        GSDII.initrunning(); //주행을 위한 초기화

	if(GSDII.loadmaze(fname)==0) {
                //파일이 존재하지 않으면.....
		setcolor(0xc);
		GSDII.putmassage(20, "file not found !!");
                cout << '\x7'; //'삑' 소리를 출력한다.
		delay(500);
		setcolor(0x0);
		GSDII.putmassage(20, "file not found !!");
	}
}

// arg_num: 도스 커맨드라인에서 입력된 인자의 수
// *arg[] : 도스 커맨드라인에서 입력된 값을 가진 배열
//
// ex>
// gsdsim2 a b c
// arg_num=4
// arg[0]="a"
// arg[1]="b"
// arg[2]="c"
// 즉, arg_num은 실행파일 명 뒤의 인자의 (개수+1)의 값을 가진다.
void main(int arg_num, char *arg[])
{
	initgr();

        //화면상의 미로의 위치, 블록의 폭, 벽의 폭 등을 설정
        GSDII.initwindow(0, 0, 29, 3);

        //커맨드라인에 한개의 인자라도 들오왔으면...
	if(arg_num>1) {
                //화일을 읽어들임
		if(!GSDII.loadmaze(arg[1])) {
                        //화일이 존재하지 않으면...
			closegr();
			cout << "File not found !!!!";
			return;
		}
	}

	while(1) {
		switch(getch()) {
                        //'ESC' 키가 눌렸으면...
			case 27: closegr(); return;

                        //'r' or 'R' 키가 눌렸으면...
			case 'R':
			case 'r':
                                running(); //주행을 시작
			break;

                        //'l' or 'L' 키가 눌렸으면...
			case 'L':
                        case 'l': loadfile(); //파일을 읽어들임
			break;

		}
	}
}
