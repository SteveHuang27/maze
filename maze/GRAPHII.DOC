//=====================================
//
//  저씨더 II 시뮬레이션 프로그램 V2.0
//
//        그래픽 관련 부분 1997.1.6
//  호서대학 하이텍 연구실 '94 김현준
//=====================================

#include <fstream.h>
#include <graphics.h>
#include <math.h>
#include <conio.h>
#include <dos.h>
#include "graphii.h"

//그래픽 초기화 함수
void initgr(void)
{
	int gd=VGA, gm=VGAHI;
	initgraph(&gd, &gm, "");
}

//그래픽 종료 함수
void closegr(void)
{
	closegraph();
}

//미로 클래스의 생성자
//미로 클래스를 생성할 때 시뮬레이션할 맵을 초기화 한다.
MIRO::MIRO()
{
	initwallmap(simmap);

	for(int i=0;i<34*17;i++) {
		if(simmap[i]==XX_WALL) simmap[i]=NO_WALL;
	}
}

//미로 클래스의 파괴자
MIRO::~MIRO()
{
}

//미로의 시작점, 블록 간격, 벽두께 등을 설정한다.
// 미로의 화면상의 시작 포인트: w_x, w_y
// 블록 간격: b_w
// 벽두께: w_w
void MIRO::setMIRO(int w_x, int w_y, int b_w, int w_w)
{
        //클래스 내의 변수들을 초기화한다.
	win_x=w_x; win_y=w_y;
	bw=b_w; ww=w_w;

        //마우스가 실제로 달리때 벽정보를 저장하는 맵이 wallmap인데,
        //이 맵을 벽정보를 전혀 모를 초기상태로 초기화한다.
	initwallmap(wallmap);

        drawpole(); //폴을 화면에 그린다.

        //맵에 저장된 벽정보에 따라서
        //미로를 화면상에 그린다.
        // EMPTY_WALL: 속이 빈 벽
        // SOLID_WALL: 속이 채워진 벽
        drawmaze(wallmap, SOLID_WALL);
	drawmaze(simmap, EMPTY_WALL);
}

//미로의 가장자리의 벽들, 즉 맨 바깥쪽 벽들은
//언제나 막혀 있으므로 이를 초기화 해 주어야한다.
//이 때 사용되는 함수이다.
// map: 초기화할 벽지도
// spos: 벽지도 상의 초기화할 시작주소
// delta: 주소의 변화분
void MIRO::setboder(char *map, int spos, int delta)
{
	int i=16;

	while(i--) { map[spos]=YES_WALL; spos+=delta; }
}

//벽지도를 초기화하는 함수
void MIRO::initwallmap(char *map)
{
	int i;

        for(i=0;i<34*17;i++) map[i]=XX_WALL; //모든벽을 모르는 벽으로 설정

        setboder(map, 32, 34); //북쪽 가장자리 벽들을 설정
        setboder(map, 34*16+1, 2); //동쪽 가장자리 벽들을 설정
        setboder(map, 0, 34); //남쪽 가장자리 벽들을 설정
        setboder(map, 1, 2); //서쪽 가장자리 벽들을 설정
        map[2]=NO_WALL; //출발점에서 앞쪽벽이 없는 벽으로 설정
        map[35]=YES_WALL; //출발점에서 왼쪽벽이 있는 벽으로 설정
}

//폴을 화면에 그리는 함수
void MIRO::drawpole(void)
{
	int i,j;

        setfillstyle(SOLID_FILL, 0xb); //색깔과 채우는 패턴을 설정

	for(i=0;i<17;i++) {
		for(j=0;j<17;j++) {
                        //16*16 미로의 폴을 화면에 그림
                        // win_x, win_y: 미로의 시작점
                        // bw: 블록의 폭
                        // ww: 벽두께
			bar(win_x+bw*i, win_y+bw*j,win_x+bw*i+ww, win_y+bw*j+ww);
		}
	}
}

//pos의 위치에 type의 벽을 그린다.
//type=SOLID_WALL, EMPTY_WALL
void MIRO::putwall(int pos, int type)
{
	int x, y;

        //색깔과 채우는 패턴을 설정
	setcolor(0x9);
	setfillstyle(SOLID_FILL, 0x9);

	if(pos&1) {

                //홀수 위치일 경우
		x=win_x+bw*(pos/34);
		y=win_y+bw*(15-pos%34/2);
		if(type==EMPTY_WALL) {
			rectangle(x, y+ww+1, x+ww, y+bw-1);
		} else bar(x, y+ww+1, x+ww, y+bw-1);

	} else {

                //짝수 위치일 경우
		x=win_x+bw*(pos/34);
		y=win_y+bw*(16-pos%34/2);
		if(type==EMPTY_WALL) {
			rectangle(x+ww+1, y, x+bw-1, y+ww);
		} else bar(x+ww+1, y, x+bw-1, y+ww);
	}
}

//맵의 정보에 따라서 벽정보를 화면상에 그림
void MIRO::drawmaze(char *map, int type)
{
	int i;

	for(i=0;i<34*17;i++) {
                //벽이 존재할 경우에만
		if(map[i]==YES_WALL) putwall(i, type);
	}

}

//방향지도를 화면에 표시하여준다.
//디버그시, 알고리즘 관찰시 등에 사용한다.
//evencolor: 짝수 위치의 색
//oddcolor: 홀수 위치의 색
void MIRO::_putdirmap(int evencolor, int oddcolor)
{
	int pos;
	int x, y;
	char s[][3]={"N","NE","E","SE","S","SW","W","NW"};

	for(pos=0;pos<34*17;pos++) {

		if(dirmap[pos]>14 && dirmap[pos]!=MAPREF) continue;

		if(pos&1) {

                        //홀수 위치의 경우
                        //표시할 위치 x, y
			setcolor(oddcolor);
			x=win_x+bw*(pos/34)+ww+4;
			y=win_y+bw*(15-pos%34/2)+ww+8;
		} else {

                        //짝수 위치의 경우
                        //표시할 위치 x, y
			setcolor(evencolor);
			x=win_x+bw*(pos/34)+ww+8;
			y=win_y+bw*(16-pos%34/2)-9;
		}

                //화면에 출력
		if(dirmap[pos]==MAPREF) outtextxy(x, y, "MR");
			else outtextxy(x,y,s[dirmap[pos]>>1]);
	}
}

//화면에 방향지도를 그렸다가, 임의의 키를 누르면
//방향지도를 지운후 리턴
void MIRO::putdirmap(void)
{
	_putdirmap(2, 4);
	getch();
	_putdirmap(0, 0);
}

//벽지도를 화면에 표시하여준다.
//디버그시 등에 사용한다.
//evencolor: 짝수 위치의 색
//oddcolor: 홀수 위치의 색
void MIRO::_putwallmap(int evencolor, int oddcolor)
{
	int pos;
	int x, y;

	for(pos=0;pos<34*17;pos++) {

		if(pos&1) {

                        //홀수 위치의 경우
                        //표시할 위치 x, y
			setcolor(oddcolor);
			x=win_x+bw*(pos/34)+ww+4;
			y=win_y+bw*(15-pos%34/2)+ww+8;
		} else {

                        //짝수 위치의 경우
                        //표시할 위치 x, y
			setcolor(evencolor);
			x=win_x+bw*(pos/34)+ww+8;
			y=win_y+bw*(16-pos%34/2)-9;
		}

                //벽정보에 따라서 화면에 표시
                //yes: 벽이 있음
                //xx: 모르는 벽
                //no: 벽이 없음
		switch(wallmap[pos]) {
			case YES_WALL: outtextxy(x, y, "yes");
			break;
			case XX_WALL: outtextxy(x, y, "xx");
			break;
			case NO_WALL: outtextxy(x, y, "no");
			break;
		}
	}
}

//벽지도를 화면에 표시한 후, 임의의 키를 누르면
//벽지도를 화면에서 지운 후 리턴
void MIRO::putwallmap(void)
{
	_putwallmap(2, 4);
	getch();
	_putwallmap(0, 0);
}

//시뮬레이션할 벽지도 파일을 읽어들임
//파일 포멧은 확장자 ".MAZ" 파일 형식이다.
//
// MAZE 파일 포맷
//
//      |모름/앎| 유/무 |
//      | 1  / 0| 1 / 0 |
// 비트  7 6 5 4 3 2 1 0
//      +-+-+-+-+-+-+-+-+
// 방향 |W|S|E|N|W|S|E|N|
//      +-+-+-+-+-+-+-+-+
int MIRO::loadmaze(char *filename)
{
	int i;
	char mirodata;

        //시뮬레이션 멥에 모두 "벽이 없음"으로 채운다.
	for(i=0;i<34*17;i++) simmap[i]=NO_WALL;

        //파일을 연다
	ifstream maze(filename, ios::binary);

	if(maze.fail()) {
                //파일을 찾지 못하였으면 시뮬레이션 멥을 초기화 한다.
                initwallmap(simmap);

		for(int i=0;i<34*17;i++) {
			if(simmap[i]==XX_WALL) simmap[i]=NO_WALL;
		}

                //파일을 닫고 리턴
		maze.close();
                //파일 오픈 실패를 나타낸다.
		return 0;
	}

        //파일을 찾으면 한 바이트씩 읽어서 처리한다.
	for(i=0;i<256;i++) {
                if(!maze.get(mirodata)) break; //파일의 끝이면 for문을 중지

                //북쪽 방향에 벽이 있으면
                //simmap에 '벽이 있음(YES_WALL)'을 저장
		if(mirodata&1) simmap[i*2+(int)(i/16)*2+2]=YES_WALL;

                //동쪽 방향에 벽이 있으면
                //simmap에 '벽이 있음(YES_WALL)'을 저장
		if(mirodata&2) simmap[i*2+(int)(i/16)*2+35]=YES_WALL;

                //납쪽 방향에 벽이 있으면
                //simmap에 '벽이 있음(YES_WALL)'을 저장
		if(mirodata&4) simmap[i*2+(int)(i/16)*2]=YES_WALL;

                //서쪽 방향에 벽이 있으면
                //simmap에 '벽이 있음(YES_WALL)'을 저장
		if(mirodata&8) simmap[i*2+(int)(i/16)*2+1]=YES_WALL;
	}

	maze.close();

        //읽어들인 벽정보를 화면에 그린다.
	drawmaze(simmap, EMPTY_WALL);

        //성공적으로 파일을 불러들였음을 나타낸다
	return 1;
}

//생성자
MOUSE::MOUSE()
{
	speed=10;
	flag=0;
}

//파괴자
MOUSE::~MOUSE()
{
}

//마우스를 출발위치로 설정
void MOUSE::sethome(int w_x, int w_y, int b_w, int w_w)
{
	x=w_x+w_w+(double)((b_w-w_w)/2);
	y=w_y+w_w+(double)((b_w-w_w)/2)+b_w*15;
	dir=0.;
	movemouse(0);
}

//마우스가 움직이는 스피드를 설정
void MOUSE::setspeed(int _speed)
{
	speed=_speed;
        //실제로 speed라는 변수가 움직이는 속도값을 가지고 있다
}

//마우스를 현재 방향(dir)으로 일정거리(dist) 만큼 움직인다
void MOUSE::movemouse(double dist)
{
        //이전의 위치값은 이전의 마우스를 지우기 위해 사용
        oldx=x; //이전의 마우스의 위치값 x
        oldy=y; //이전의 마우스의 위치값 y

        //변화될 마우스의 위치값을 계산한다
	x=x+dist * sin( dir/180.*M_PI );
	y=y-dist * cos( dir/180.*M_PI );

        //계산된 마우스의 위치값으로
        //삼각형인 마우스의 각 꼭지점의 위치값을 계산

        //꼭지점 1
	mloc[0]= x+5 * sin( dir/180.*M_PI );
	mloc[1]= y-5 * cos( dir/180.*M_PI );

        //꼭지점 2
	mloc[2]= x+5 * sin( (dir+120.)/180.*M_PI );
	mloc[3]= y-5 * cos( (dir+120.)/180.*M_PI );

        //꼭지점 3
	mloc[4]= x+5 * sin( (dir-120.)/180.*M_PI );
	mloc[5]= y-5 * cos( (dir-120.)/180.*M_PI );

        //마우스를 화면에 출력
	putmouse();
        //일정시간 지연
	delay(speed);
}

//마우스를 angle 만큼 회전
//화면에는 변화 없음, putmouse 함수로만 움직인다.
void MOUSE::turnmouse(double angle)
{
	dir=fmod(dir+angle, 360.);
}

//화면에서 마우스를 실제로 움직인다
void MOUSE::putmouse(void)
{
        //이전의 마우스를 지운다
	erasemouse();

        //마우스가 지나간 자리의 흔적, 점을 찍는다
	putpixel(x, y, 1);

        //현재의 마우스 위치의 배경화면 정보를 저장한다
	getimage(x-6, y-6, x+6, y+6, image);

        //마우스의 색깔과 채우는 패턴을 설정
	setcolor(0xf);
	setfillstyle(SOLID_FILL, 5);
        //마우스를 그린다
	fillpoly(3, mloc);
        //flag=1, 즉, 마우스가 현재 그려져 있음을 나타낸다
	flag=1;
}

//마우스를 화면에서 지운다.
void MOUSE::erasemouse(void )
{
        //flag==0, 즉 마우스가 현재 그려져 있지 않으면 그냥 리턴
	if(!flag) return;
        //이전의 마우스 위치의 배경화면 정보를 복구
	putimage(oldx-6, oldy-6, image, COPY_PUT);
        //flag=0, 즉, 마우스가 현재 그려져 있지 않음을 나타낸다
	flag=0;
}

//마우스를 현재 방향(dir)로 일정거리(dist)만큼 움직인다.
//movemouse()를 호출하여 짧은 거리로 여러번 움직여 dist 만큼의
//거리를 움직인다. 즉, 한 블록을 한번에 움직이면 화면 표시가
//자연스럽지 않기 때문에 여러번 나누어서 움직인다.
void MOUSE::running(double dist)
{
	double i=0;

	while(1) {
                i+=5;  //한 번에 5 만큼 움직인다.
                if(i>=dist) break; //dist보다 크거나 같은면 while문을
                                   //빠진다.
                movemouse(5); //5 만큼의 거리를 움직임
	}

        movemouse(dist-(i-5)); //정확하게 dist거리를 움직이게 보정한다.
}

//마우스을 일정 각도(angle) 만큼 회전한다.
//실제로 화면에서도 움직인다.
void MOUSE::turnning(double angle)
{

	double i=0;
	double next_dir;

        next_dir=fmod(dir+angle, 360.); //angle 만큼 턴한 방향을 구한다.

        //조금씩턴하여 자연스럽게 화면에 표시

        //왼쪽으로 턴
	if(angle<0) {
		while(1) {
			i-=5;
			if(i<=angle) break;
			dir=i;
			movemouse(0);
		}
	}

        //오른쪽으로 턴
	if(angle>0) {
		while(1) {
			i+=5;
			if(i>=angle) break;
			dir=i;
			movemouse(0);
		}
	}

        //다음방향을 정확하게 맞춘다.
	dir=next_dir;
	movemouse(0);
}

