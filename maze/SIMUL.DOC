//=====================================
//
//  저씨더 II 시뮬레이션 프로그램 V2.0
//
//      알고리즘 관련 부분 1997.1.6
//  호서대학 하이텍 연구실 '94 김현준
//=====================================

#include <dos.h>
#include <stdio.h>
#include <graphics.h>
#include <iostream.h>
#include <process.h>
#include <math.h>
#include "graphii.h"
#include "simul.h"

//SIMULATION 클래스의 생성자
SIMULATION::SIMULATION() : MIRO(), MOUSE()
{
}

//SIMULATION 클래스의 파괴자
SIMULATION::~SIMULATION()
{
}

//화면상에 표시될 미로의 시작위치,
//블록의 폭, 벽의 두께 등을 설정
//w_x: 미로의 시작점(최왼쪽 가장 윗부분 점)의 x좌표
//w_y: 미로의 시작점(최왼쪽 가장 윗부분 점)의 y좌표
//b_w: 한 블록의 폭
//w_w: 벽의 두께
void SIMULATION::initwindow(int w_x, int w_y, int b_w, int w_w)
{
	flag=0;

        //미로를 설정
	setMIRO(w_x, w_y, b_w, w_w);
        //마우스를 초기위치(시작점)에...
	sethome(w_x, w_y, b_w, w_w);

        //화면에 기본 도움말을 출력한다.
	titlemassage();
}

//주행전의 초기화 작업
void SIMULATION::initrunning()
{
        flag=0; //마우스가 표시되지 않은 상태로 설정

        //화면을 지운다.
	cleardevice();
        //미로를 설정
	setMIRO(win_x, win_y, bw, ww);
        //마우스를 초기위치(시작점)에...
	sethome(win_x, win_y, bw, ww);

        //화면에 기본 도움말(초기 메세지)을 출력한다.
	titlemassage();

        //마우스의 방향을 북쪽으로 설정
	mdir=0;
        //마우스의 위치를 시작점으로 설정
	mpos=2;
}

//시뮬레이션 맵을 초기화한다.
//즉, 가장자리에만 벽이 있고, 나머지는 벽이 없는
//미로를 만든다.
void SIMULATION::clearsimmap()
{
        //시뮬레이션 맵을 초기화
        //이 때에는 미로의 가장자리 외에는 모르는 벽으로 설정된다.
	initwallmap(simmap);

        //나머지 벽들을 모두 벽이 없는 것으로 처리한다.
	for(int i=0;i<34*17;i++) {
		if(simmap[i]==XX_WALL) simmap[i]=NO_WALL;
	}
}

//목표점을 goal변수가 가진 값으로 설정하고,
//벽 판별라인을 정한다.
//_walldetline가 NO_WALL이면 모르는 벽은 있는 것으로 간주하고,
//_walldetline가 XX_WALL이면 모르는 벽은 없는 것으로 간주한다.
void SIMULATION::set_to_goal(int _walldetline)
{
	target=goal;
	walldetline=_walldetline;
}

//목표점을 시작점으로 설정
//_walldetline는 set_to_goal과 동일
void SIMULATION::set_to_home(int _walldetline)
{
	target=2;
	walldetline=_walldetline;
}

//goal이란 변수에 최종 목표(4 목표점 가운데 가장 좋은 목표점)
//점을 설정하거나, goal에 초기값을 대입
//즉, 처음 목표점은 위치 값이 289인데 처음 주행 초기화시에는
//goal은 289의 값을 같다가, 목표점을 찾은 후에는 가장 좋은 목표점의
//값을 갖게 된다.
void SIMULATION::setgoal(int _goal)
{
	goal=_goal;
}

//가상 마우스를 퍼뜨리기 위한 초기화
void SIMULATION::initspread()
{
	int i;

        //벽지도(wallmap)에 따라서 방향지도(dirmap)을 초기화
        //벽에 있는곳이면 (MAPREF-1)값을 갖고, 벽이 없으면 MAPREF
        //값을 갖는다. 즉, MAPREF 값을 가진 곳이 곳 가상마우스가
        //움직일 수 있는 점이다.
	for(i=0;i<34*17;i++) {
		if(wallmap[i]<=walldetline) dirmap[i]=MAPREF;
			else dirmap[i]=MAPREF-1;
	}

        //버퍼 포인터를 모두 지운다.
        //즉, 버퍼에 아무것도 없음을 표시한다.
	bp[0]=bp[1]=bp[2]=bp[3]=0;

        //마우스의 위치, 방향을 버퍼 0에 로드한다.
        //즉, 가상마우스는 마우스의 위치에서 부터 퍼뜨리게 된다.
	buffer[0][bp[0]++]=mpos;
	buffer[0][bp[0]++]=mdir;
}

//bf 버퍼에 있는 가상마우스의 자손을 퍼뜨린다.
//즉, bf=0 이면 0번 버퍼, bf=1 이면 1번 버퍼의 식
//한 가상마우스가 이동할 수 있는 모든 방향으로 자손 가상마우스를
//다시 만들어 낸다.
void SIMULATION::spread(int bf)
{
        int ipos, idir; //가상마우스의 위치, 방향

//자손 가상마우스의 위치를 버퍼에 저장하는 매크로
#define pushpos(pos, wgt) buffer[(bf+wgt)%4][bp[(bf+wgt)%4]++]=pos
//자손 가상마우스의 방향을 버퍼에 저장하는 매크로
#define pushdir(dir, wgt) buffer[(bf+wgt)%4][bp[(bf+wgt)%4]++]=dir

        //처리할 버퍼에서 가상마우스의 방향과, 위치를 읽어들임
	idir=buffer[bf][--bp[bf]];
	ipos=buffer[bf][--bp[bf]];

        //현재 가상마우스의 위치가 다른 가상마우스가 움직일
        //수 있는 자리이고, 다른 가상마우스가 가지 않았다면
        //자손을 퍼뜨리고(다음 라인을 실행), 그렇지 않으면
        //함수 수행을 종료한다(리턴한다).
	if(dirmap[ipos]!=MAPREF) return;

        //방향지도에 현재 가상마우스의 방향을 기록한다.
        //즉, 이전의 선조 가상마우스가 자손 가상마우스를
        //만들면서 이동해온 방향이 기록이 된다.
	dirmap[ipos]=idir;

	if(ipos&1) {

                //현재(ipos) 가상마우스의 위치가 홀수이면
		switch(idir) {

                        //가상마우스의 방향
                          |
                          V
			case dN:
			case dS:
                                //가상마우스의 방향이 있을 수 없는 방향임.
                                //에러를 표시하고 프로그램을 종료한다.
                                closegr();
                                cout << "error ODD position !!";
                                exit(0);
                        break;

                        //가상마우스의 방향이 동쪽일 경우이고, 나머지
                        //가상마우스에 대한 것도 동일함으로 설명은 한 방향에
                        //대해서만 한다.
                        case dE:
                                //Front(선조 가상마우스로부터 계속직진으로 주행)
                                //----즉, Left 45일 경우 선조 가상마우스로 부터
                                //        Left 45로 주행한 것이다. 이에 따라서
                                //        주행 웨이트(가중치)가 주어진다.
                                //        턴이 직진보다 오래걸리기 때문에 이에
                                //        따른 불합리한 점을 피하기 위해서 이다.
                                //
                                //현재가상마우스가 진행하는 방향이 동쪽이므로
                                //직진은 동쪽으로 가는 가상마우스일 경우이다.
                                //동쪽이 자손을 퍼뜨릴 수 있는 위치이면...
                                if(dirmap[ipos+oE]==MAPREF) {
                                        //자손 가상마우스의 위치를 버퍼에 저장
                                        //이 때 Wxxxx(WFRONT와 같은 것들)
                                        //은 가상마우스가 가는 위치의 주행
                                        //가중치이다. 이는 몇번 째의 버퍼로
                                        //가상마우스를 넣을지로 결정된다.
                                        //-pushpos 매크로 참조
                                        //버퍼는 0->1->2->3->0 순으로 순차적
                                        //을 처리되는데, 처리중인 바로 다음
                                        //버퍼로 넣으면 가장 빨리 처리되고,
                                        //2후의 버퍼로 넣으면 그만큼 그 버퍼는
                                        //늦게 처리되기 때문에 가중치가 자연히
                                        //주어지게 된다.
                                        pushpos(ipos+oE, WFRONT);
                                        //자손 가상마우스의 방향을 버퍼에 저장
                                        pushdir(dE, WFRONT);
                                }

                                //Left 45
                                if(dirmap[ipos+oNE]==MAPREF) {
                                        pushpos(ipos+oNE, WTURN45);
                                        pushdir(dNE, WTURN45);
                                }

                                //Right 45
                                if(dirmap[ipos+oSE]==MAPREF) {
                                        pushpos(ipos+oSE, WTURN45);
                                        pushdir(dSE, WTURN45);
				}

				//Left135
				if(dirmap[ipos+oNW]==MAPREF) {
					pushpos(ipos+oNW, WTURN135);
					pushdir(dNW, WTURN135);
				}

				//Right 135
				if(dirmap[ipos+oSW]==MAPREF) {
					pushpos(ipos+oSW, WTURN135);
					pushdir(dSW, WTURN135);
				}

				//Back
				if(dirmap[ipos+oW]==MAPREF) {
					pushpos(ipos+oW, WTURN180);
					pushdir(dW, WTURN180);
				}

			break;

			case dW:

				//Front
				if(dirmap[ipos+oW]==MAPREF) {
					pushpos(ipos+oW, WFRONT);
					pushdir(dW, WFRONT);
				}

				//Left 45
				if(dirmap[ipos+oSW]==MAPREF) {
					pushpos(ipos+oSW, WTURN45);
					pushdir(dSW, WTURN45);
				}

				//Right 45
				if(dirmap[ipos+oNW]==MAPREF) {
					pushpos(ipos+oNW, WTURN45);
					pushdir(dNW, WTURN45);
				}

				//Left135
				if(dirmap[ipos+oSE]==MAPREF) {
					pushpos(ipos+oSE, WTURN135);
					pushdir(dSE, WTURN135);
				}

				//Right 135
				if(dirmap[ipos+oNE]==MAPREF) {
					pushpos(ipos+oNE, WTURN135);
					pushdir(dNE, WTURN135);
				}

				//Back
				if(dirmap[ipos+oE]==MAPREF) {
					pushpos(ipos+oE, WTURN180);
					pushdir(dE, WTURN180);
				}

			break;

			case dNE:

				//Front ;45-degree path
				if(dirmap[ipos+oNE]==MAPREF) {
					pushpos(ipos+oNE, WPATH45);
					pushdir(dNE, WPATH45);
				}

				//Right 45
				if(dirmap[ipos+oE]==MAPREF) {
					pushpos(ipos+oE, WTURN45);
					pushdir(dE, WTURN45);
				}

				//Left 90
				if(dirmap[ipos+oNW]==MAPREF) {
					pushpos(ipos+oNW, WTURN90);
					pushdir(dNW, WTURN90);
				}

				//Right 90
				if(dirmap[ipos+oSE]==MAPREF) {
					pushpos(ipos+oSE, WTURN90);
					pushdir(dSE, WTURN90);
				}

				//Left 135
				if(dirmap[ipos+oW]==MAPREF) {
					pushpos(ipos+oW, WTURN135);
					pushdir(dW, WTURN135);
				}

				//Back
				if(dirmap[ipos+oSW]==MAPREF) {
					pushpos(ipos+oSW, WTURN180);
					pushdir(dSW, WTURN180);
				}

			break;

			case dSE:

				//Front ;45-degree path
				if(dirmap[ipos+oSE]==MAPREF) {
					pushpos(ipos+oSE, WPATH45);
					pushdir(dSE, WPATH45);
				}

				//Left 45
				if(dirmap[ipos+oE]==MAPREF) {
					pushpos(ipos+oE, WTURN45);
					pushdir(dE, WTURN45);
				}

				//Left 90
				if(dirmap[ipos+oNE]==MAPREF) {
					pushpos(ipos+oNE, WTURN90);
					pushdir(dNE, WTURN90);
				}

				//Right 90
				if(dirmap[ipos+oSW]==MAPREF) {
					pushpos(ipos+oSW, WTURN90);
					pushdir(dSW, WTURN90);
				}

				//Right 135
				if(dirmap[ipos+oW]==MAPREF) {
					pushpos(ipos+oW, WTURN135);
					pushdir(dW, WTURN135);
				}

				//Back
				if(dirmap[ipos+oNW]==MAPREF) {
					pushpos(ipos+oNW, WTURN180);
					pushdir(dNW, WTURN180);
				}

			break;

			case dSW:

				//Front ;45-degree path
				if(dirmap[ipos+oSW]==MAPREF) {
					pushpos(ipos+oSW, WPATH45);
					pushdir(dSW, WPATH45);
				}

				//Right 45
				if(dirmap[ipos+oW]==MAPREF) {
					pushpos(ipos+oW, WTURN45);
					pushdir(dW, WTURN45);
				}

				//Left 90
				if(dirmap[ipos+oSE]==MAPREF) {
					pushpos(ipos+oSE, WTURN90);
					pushdir(dSE, WTURN90);
				}

				//Right 90
				if(dirmap[ipos+oNW]==MAPREF) {
					pushpos(ipos+oNW, WTURN90);
					pushdir(dNW, WTURN90);
				}

				//Left 135
				if(dirmap[ipos+oE]==MAPREF) {
					pushpos(ipos+oE, WTURN135);
					pushdir(dE, WTURN135);
				}

				//Back
				if(dirmap[ipos+oNE]==MAPREF) {
					pushpos(ipos+oNE, WTURN180);
					pushdir(dNE, WTURN180);
				}

			break;

			case dNW:

				//Front ;45-degree path
				if(dirmap[ipos+oNW]==MAPREF) {
					pushpos(ipos+oNW, WPATH45);
					pushdir(dNW, WPATH45);
				}

				//Left 45
				if(dirmap[ipos+oW]==MAPREF) {
					pushpos(ipos+oW, WTURN45);
					pushdir(dW, WTURN45);
				}

				//Left 90
				if(dirmap[ipos+oSW]==MAPREF) {
					pushpos(ipos+oSW, WTURN90);
					pushdir(dSW, WTURN90);
				}

				//Right 90
				if(dirmap[ipos+oNE]==MAPREF) {
					pushpos(ipos+oNE, WTURN90);
					pushdir(dNE, WTURN90);
				}

				//Right 135
				if(dirmap[ipos+oE]==MAPREF) {
					pushpos(ipos+oE, WTURN135);
					pushdir(dE, WTURN135);
				}

				//Back
				if(dirmap[ipos+oSE]==MAPREF) {
					pushpos(ipos+oSE, WTURN180);
					pushdir(dSE, WTURN180);
				}

			break;

		}

	} else {

                //현재 가상마우스의 위치(ipos)가 짝수이면...
		switch(idir) {

			case dE:
			case dW:
				closegr();
				cout << "error EVEN position !!";
				exit(0);
			break;

			case dN:

				//Front
				if(dirmap[ipos+eN]==MAPREF) {
					pushpos(ipos+eN, WFRONT);
					pushdir(dN, WFRONT);
				}

				//Left 45
				if(dirmap[ipos+eNW]==MAPREF) {
					pushpos(ipos+eNW, WTURN45);
					pushdir(dNW, WTURN45);
				}

				//Right 45
				if(dirmap[ipos+eNE]==MAPREF) {
					pushpos(ipos+eNE, WTURN45);
					pushdir(dNE, WTURN45);
				}

				//Left 135
				if(dirmap[ipos+eSW]==MAPREF) {
					pushpos(ipos+eSW, WTURN135);
					pushdir(dSW, WTURN135);
				}

				//Right 135
				if(dirmap[ipos+eSE]==MAPREF) {
					pushpos(ipos+eSE, WTURN135);
					pushdir(dSE, WTURN135);
				}

				//Back
				if(dirmap[ipos+eS]==MAPREF) {
					pushpos(ipos+eS, WTURN180);
					pushdir(dS, WTURN180);
				}

			break;

			case dS:

				//Front
				if(dirmap[ipos+eS]==MAPREF) {
					pushpos(ipos+eS, WFRONT);
					pushdir(dS, WFRONT);
				}

				//Left 45
				if(dirmap[ipos+eSE]==MAPREF) {
					pushpos(ipos+eSE, WTURN45);
					pushdir(dSE, WTURN45);
				}

				//Right 45
				if(dirmap[ipos+eSW]==MAPREF) {
					pushpos(ipos+eSW, WTURN45);
					pushdir(dSW, WTURN45);
				}

				//Left 135
				if(dirmap[ipos+eNE]==MAPREF) {
					pushpos(ipos+eNE, WTURN135);
					pushdir(dNE, WTURN135);
				}

				//Right 135
				if(dirmap[ipos+eNW]==MAPREF) {
					pushpos(ipos+eNW, WTURN135);
					pushdir(dNW, WTURN135);
				}

				//Back
				if(dirmap[ipos+eN]==MAPREF) {
					pushpos(ipos+eN, WTURN180);
					pushdir(dN, WTURN180);
				}

			break;

			case dNE:

				//Front ;45-degree path
				if(dirmap[ipos+eNE]==MAPREF) {
					pushpos(ipos+eNE, WPATH45);
					pushdir(dNE, WPATH45);
				}

				//Left 45
				if(dirmap[ipos+eN]==MAPREF) {
					pushpos(ipos+eN, WTURN45);
					pushdir(dN, WTURN45);
				}

				//Left 90
				if(dirmap[ipos+eNW]==MAPREF) {
					pushpos(ipos+eNW, WTURN90);
					pushdir(dNW, WTURN90);
				}

				//Right 90
				if(dirmap[ipos+eSE]==MAPREF) {
					pushpos(ipos+eSE, WTURN90);
					pushdir(dSE, WTURN90);
				}

				//Right 135
				if(dirmap[ipos+eS]==MAPREF) {
					pushpos(ipos+eS, WTURN135);
					pushdir(dS, WTURN135);
				}

				//Back
				if(dirmap[ipos+eSW]==MAPREF) {
					pushpos(ipos+eSW, WTURN180);
					pushdir(dSW, WTURN180);
				}

			break;

			case dSE:

				//Front ;45-degree path
				if(dirmap[ipos+eSE]==MAPREF) {
					pushpos(ipos+eSE, WPATH45);
					pushdir(dSE, WPATH45);
				}

				//Right 45
				if(dirmap[ipos+eS]==MAPREF) {
					pushpos(ipos+eS, WTURN45);
					pushdir(dS, WTURN45);
				}

				//Left 90
				if(dirmap[ipos+eNE]==MAPREF) {
					pushpos(ipos+eNE, WTURN90);
					pushdir(dNE, WTURN90);
				}

				//Right 90
				if(dirmap[ipos+eSW]==MAPREF) {
					pushpos(ipos+eSW, WTURN90);
					pushdir(dSW, WTURN90);
				}

				//Left 135
				if(dirmap[ipos+eN]==MAPREF) {
					pushpos(ipos+eN, WTURN135);
					pushdir(dN, WTURN135);
				}

				//Back
				if(dirmap[ipos+eNW]==MAPREF) {
					pushpos(ipos+eNW, WTURN180);
					pushdir(dNW, WTURN180);
				}

			break;

			case dSW:

				//Front ;45-degree path
				if(dirmap[ipos+eSW]==MAPREF) {
					pushpos(ipos+eSW, WPATH45);
					pushdir(dSW, WPATH45);
				}

				//Left 45
				if(dirmap[ipos+eS]==MAPREF) {
					pushpos(ipos+eS, WTURN45);
					pushdir(dS, WTURN45);
				}

				//Left 90
				if(dirmap[ipos+eSE]==MAPREF) {
					pushpos(ipos+eSE, WTURN90);
					pushdir(dSE, WTURN90);
				}

				//Right 90
				if(dirmap[ipos+eNW]==MAPREF) {
					pushpos(ipos+eNW, WTURN90);
					pushdir(dNW, WTURN90);
				}

				//Right 135
				if(dirmap[ipos+eN]==MAPREF) {
					pushpos(ipos+eN, WTURN135);
					pushdir(dN, WTURN135);
				}

				//Back
				if(dirmap[ipos+eNE]==MAPREF) {
					pushpos(ipos+eNE, WTURN180);
					pushdir(dNE, WTURN180);
				}

			break;

			case dNW:

				//Front ;45-degree path
				if(dirmap[ipos+eNW]==MAPREF) {
					pushpos(ipos+eNW, WPATH45);
					pushdir(dNW, WPATH45);
				}

				//Right 45
				if(dirmap[ipos+eN]==MAPREF) {
					pushpos(ipos+eN, WTURN45);
					pushdir(dN, WTURN45);
				}

				//Left 90
				if(dirmap[ipos+eSW]==MAPREF) {
					pushpos(ipos+eSW, WTURN90);
					pushdir(dSW, WTURN90);
				}

				//Right 90
				if(dirmap[ipos+eNE]==MAPREF) {
					pushpos(ipos+eNE, WTURN90);
					pushdir(dNE, WTURN90);
				}

				//Left 135
				if(dirmap[ipos+eS]==MAPREF) {
					pushpos(ipos+eS, WTURN135);
					pushdir(dS, WTURN135);
				}

				//Back
				if(dirmap[ipos+eSE]==MAPREF) {
					pushpos(ipos+eSE, WTURN180);
					pushdir(dSE, WTURN180);
				}

			break;

		}
	}

}

//가상마우스를 방향지도(dirmap)에 퍼뜨린다.
//방향지도라고 이름지은 이유는, 움직인
//가상마우스의 방향만이 기록되기 때문이다.
void SIMULATION::makeshortmap()
{
        //가상마우스를 퍼뜨리기 위한 초기화
        //dirmap에 움직일 수 있는 위치는 MAPREF로 설정
        //퍼뜨리기 시작할 위치와 방향을 버퍼 0에 저장
	initspread();

	while(1) {
                //버퍼 0가 빌 때까지 가상마우스를 버퍼 0에서 읽어서 퍼뜨림
		while(bp[0]) spread(0);
                //버퍼 1가 빌 때까지 가상마우스를 버퍼 1에서 읽어서 퍼뜨림
		while(bp[1]) spread(1);
                //버퍼 2가 빌 때까지 가상마우스를 버퍼 2에서 읽어서 퍼뜨림
		while(bp[2]) spread(2);

                //만약, 목표점까지 가상마우스를 퍼뜨렸으면 중단하고 끝낸다.
		if(dirmap[target]!=MAPREF) return;

                //버퍼 1가 빌 때까지 가상마우스를 버퍼 1에서 읽어서 퍼뜨림
		while(bp[3]) {

                        //만약, 목표점까지 가상마우스를 퍼뜨렸으면
                        //중단하고 끝낸다.
			if(dirmap[target]!=MAPREF) return;
			spread(3);
		}
	}
}

#define GO_18CM 16
#define GO_13CM 18

//가상마우스를 역추적하여 목표로 이동하는 최단거리 경로를 연산
//목표점으로부터 실제 마우스가 있는 위치를 역추적하는데, 이 때
//현재 마우스 위치에서 목표로가는 최단거리 경로가 tracebuf에
//저장되고 tracer가 저장된 의 끝을 가르친다.
void SIMULATION::tracepath()
{
	int ipos,curdir, olddir;

        //가상마우스를 퍼뜨려 방향지도를 그림
	makeshortmap();

        //tracer: 단거리 경로 저장버퍼의 포인터
	tracer=tracebuf;

        //ipos: 추적시의 가상마우스의 위치
	ipos=target;

        //현재 방향지도로 부터 읽어들인 가상마우스가
        //움직였던 방향값
	curdir=dirmap[ipos];

        //현재 마우스가 있는 위치까지 추적되면 while문 수행을 중단한다.
	while(ipos!=mpos) {

                //이전 위치의 방향값을 저장
		olddir=curdir;

                //다시 방향지도에서 방향값을 읽어옴
		curdir=dirmap[ipos];

                //olddir에 움직일 방향 값(턴 값)을 계산해서 넣는다.
                //만약, 추적시 가상마우스가 NE로 이동후 N으로 이동했다면,
                //이때 턴 값은 (N-NE)&0xf이다. 즉 (0-2)&0xf는
                //0xfffe(방향 값이 워드형)&0xf는 0xe=14 즉, Left 45도 턴
                //이다. *참고: 방향, 턴 값은 simul.h에 정의되어 있다.
		olddir=(olddir-curdir)&0xf;

                //*tracer에 턴값을 저장하고, tracer을 1증가 시킨다.
		*tracer++=olddir;

                //현재 가상마우스의 방향이...
		switch(curdir) {
                        //북쪽
                        case dN:
                                //18cm 즉, 한블록 전진임을 나타내는 정의 값
                                //을 추적 버퍼(tracebuf)에 저장
                                //N, E, S, W: 는 한블록을주행(18cm)
                                //NE, SE, SW, NW: 는 45도 경로로
                                //주행하는 것임(13cm)을 참고
                                *tracer++=GO_18CM;

                                //가상마우스의 위치를 반대방향으로 움직여서
                                //역추적한다.
                                if(ipos&1) ipos+=oS;
                                        else ipos+=eS;
                        break;

                        //북동쪽
			case dNE:
				*tracer++=GO_13CM;
				if(ipos&1) ipos+=oSW;
					else ipos+=eSW;
			break;

                        //동쪽
			case dE:
				*tracer++=GO_18CM;
				if(ipos&1) ipos+=oW;
					else ipos+=eW;
			break;

                        //남서쪽
			case dSE:
				*tracer++=GO_13CM;
				if(ipos&1) ipos+=oNW;
					else ipos+=eNW;
			break;

                        //남쪽
			case dS:
				*tracer++=GO_18CM;
				if(ipos&1) ipos+=oN;
					else ipos+=eN;
			break;

                        //남서쪽
			case dSW:
				*tracer++=GO_13CM;
				if(ipos&1) ipos+=oNE;
					else ipos+=eNE;
			break;

                        //서쪽
			case dW:
				*tracer++=GO_18CM;
				if(ipos&1) ipos+=oE;
					else ipos+=eE;

			break;

                        //북서쪽
			case dNW:
				*tracer++=GO_13CM;
				if(ipos&1) ipos+=oSE;
					else ipos+=eSE;
			break;

		}
	}

        //마우스의 위치까지 추적후 실제의 마우스가 진행해야할
        //턴값을 tracerbuf의 최상위 바이트에 넣은후 리턴한다.
	olddir=curdir;
	curdir=dirmap[ipos];
	olddir=(olddir-curdir)&0xf;
	*tracer=olddir;
}

//pos 위치를 dir 방향으로 이동한다.
void SIMULATION::moveposition(int &pos, int dir)
{
        //방향(dir)이 ...
	switch(dir) {
                //북쪽일 경우...
		case dN:
                        //홀수의 위치일 경우의 방향에 따른 위치의 변화분
                        //은 oXX, 짝수의 위치일 경우의 방향에 따른 위치의
                        //의 변화분은 eXX이다.
			if(pos&1) pos+=oN;
				else pos+=eN;
		break;
		case dNE:
			if(pos&1) pos+=oNE;
				else pos+=eNE;
		break;
		case dE:
			if(pos&1) pos+=oE;
				else pos+=eE;
		break;
		case dSE:
			if(pos&1) pos+=oSE;
				else pos+=eSE;
		break;
		case dS:
			if(pos&1) pos+=oS;
				else pos+=eS;
		break;
		case dSW:
			if(pos&1) pos+=oSW;
				else pos+=eSW;
		break;
		case dW:
			if(pos&1) pos+=oW;
				else pos+=eW;
		break;
		case dNW:
			if(pos&1) pos+=oNW;
				else pos+=eNW;
		break;
	}
}

//왼쪽으로 스무드턴 한다.
void SIMULATION::lsturnning()
{
        //cnt: 왼쪽으로 스무드턴 시 걸리는 스텝
	int 	cnt=(double)bw*M_PI/4/2;

        //_angle: 한스텝 갈 때 회전할 각
	double 	_angle=-90./cnt;

        //왼쪽으로 90도 턴후의 위치(_x, _y)와 방향(_dir)
        //턴후 위치를 정확히 보정하기 위해서...
	double _dir=fmod(dir-90., 360.);
	double _x = x + M_SQRT2 * (double)bw/2 * sin( (dir-45.)/180.*M_PI );
	double _y = y - M_SQRT2 * (double)bw/2 * cos( (dir-45.)/180.*M_PI );

        //90도 회전시의 회전축
        //즉, 회전시 그리는 1/4호의 원점을 가리킨다.
	double basex = x + (double)bw/2 * sin( (dir-90.)/180.*M_PI );
	double basey = y - (double)bw/2 * cos( (dir-90.)/180.*M_PI );

	while(cnt--) {

		oldx=x; oldy=y;
		erasemouse();

                //회전원점을 기준으로 마우스의 방향에서
                //일정한각도 만큼 회전하며 마우스의 다음 위치를 계산
                //dir: 마우스의 방향
                //_angle: 한번에 회전할 각도
		x = basex + (double)bw/2 * sin( fmod(dir+_angle+90., 360.)/180.*M_PI );
		y = basey - (double)bw/2 * cos( fmod(dir+_angle+90., 360.)/180.*M_PI );

                //마우스를 _angle 만큼 회전
                //실제로 화면에서는 턴하지 않고 dir값만 변한다.
		turnmouse(_angle);

                //마우스를 화면에서 실제로 턴
		movemouse(0);
	}

        //마우스를 지운후 턴후 위치, 방향을 보정
	oldx=x; oldy=y;
	erasemouse();
	x=_x; y=_y;
	dir=_dir;
	movemouse(0);
}


//lsturnning와 거의 동일하다.
void SIMULATION::rsturnning()
{
	int 	cnt=(double)bw*M_PI/4/2;
	double 	_angle=90./cnt;

	double _dir=fmod(dir+90., 360.);
	double _x = x + M_SQRT2 * (double)bw/2 * sin( (dir+45.)/180.*M_PI );
	double _y = y - M_SQRT2 * (double)bw/2 * cos( (dir+45.)/180.*M_PI );

	double basex = x + (double)bw/2 * sin( (dir+90.)/180.*M_PI );
	double basey = y - (double)bw/2 * cos( (dir+90.)/180.*M_PI );

	while(cnt--) {

		oldx=x; oldy=y;
		erasemouse();

		x = basex + (double)bw/2 * sin( fmod(dir+_angle-90., 360.)/180.*M_PI );
		y = basey - (double)bw/2 * cos( fmod(dir+_angle-90., 360.)/180.*M_PI );

		turnmouse(_angle);
		movemouse(0);
	}

	oldx=x; oldy=y;
	erasemouse();
	x=_x; y=_y;
	dir=_dir;
	movemouse(0);
}

//쉽게 사용하기 위해서
//기본적인 마우스의 이동을 연산자 오버로드를 통해
//단순화 시켜준다.
//ex>
//SIMULATION gsd;
//gsd << GO18CM << LT45;
//연속적인 연산자의 사용을 위해 함수의 리턴 형이
//(SIMULATION &)으로 SIMULATION객체의 참조형이다.
SIMULATION &SIMULATION::operator<<(int cmd)
{

	switch(cmd) {

		case GOBLOCK:
                        //N, E, S, W 방향일 경우는 19cm을 주행,
                        //그밖의 경우는 13cm(대각선)을 주행한다.
			if(mdir==dN || mdir==dE || mdir==dS || mdir==dW) {
				running(bw);
			} else {
				running(bw*M_PI);
			}
			putposition(0);
			moveposition(mpos, mdir);
			putposition(0xf);
		break;

                //18cm을 주행
                //bw : 한 블록의 폭값
		case GO18CM:
                        //bw 만큼 전진
			running(bw);

                        //화면상에 방향, 위치 값을 지운다.
                        //인자=0는 색깔을 0으로 표시한다는 것임.
			putposition(0);

                        //마우스의 위치, 방향을 수정
			moveposition(mpos, mdir);

                        //화면상에 수정된 방향, 위치 값을 다시 표시
			putposition(0xf);;
		break;

                //13cm 전진. 즉, 대각선 한 블록 전진
		case GO13CM:
                        //bw*sqrt(2) 만큼 전진
			running(bw*M_PI);
			putposition(0);
			moveposition(mpos, mdir);
			putposition(0xf);;
		break;

                //반블록 전진
		case GO9CM:
			running(bw/2);
		break;

                //왼쪽으로 45도 턴
		case LT45:
			turnning(-45);
			putposition(0);
			mdir=(mdir-2)&0xf;
			putposition(0xf);;
		break;

                //오른쪽으로 45도 턴
		case RT45:
			turnning(45);
			putposition(0);
			mdir=(mdir+2)&0xf;
			putposition(0xf);;
		break;

                //왼쪽으로 90도 턴
		case LT90:
			turnning(-90);
			putposition(0);
			mdir=(mdir-4)&0xf;
			putposition(0xf);;
		break;

                //오른쪽으로 90도 턴
		case RT90:
			turnning(90);
			putposition(0);
			mdir=(mdir+4)&0xf;
			putposition(0xf);;

		break;

                //왼쪽으로 180도 턴
		case LT180:
			turnning(-180);
			putposition(0);
			mdir=(mdir-8)&0xf;
			putposition(0xf);;
		break;

                //오른쪽으로 180도 턴
		case RT180:
			turnning(180);
			putposition(0);
			mdir=(mdir+8)&0xf;
			putposition(0xf);;
		break;

                //왼쪽으로 스무드턴
		case LSTURN:
                        //왼쪽으로 스무드턴
			lsturnning();
			putposition(0);
			moveposition(mpos, (mdir-2)&0xf);

                        //방향값을 수정
                        //알고리즘에서는 45도 턴이었지만 실제로는
                        //90도 턴인 스무드 턴을 하게 된다.
			mdir=(mdir-4)&0xf;
			putposition(0xf);;
		break;

                //오른쪽으로 스무드턴
		case RSTURN:
                        //오른쪽으로 스무드턴
			rsturnning();
			putposition(0);
			moveposition(mpos, (mdir+2)&0xf);

                        //방향값을 수정
                        //알고리즘에서는 45도 턴이었지만 실제로는
                        //90도 턴인 스무드 턴을 하게 된다.
			mdir=(mdir+4)&0xf;
			putposition(0xf);;
		break;
		//case LDIAG:
		//case RDIAG:
	}

        //현재 객체(SIMULATION)의 값(this는 포인터이고,
        //*this는 그포인터가 참조하는 값이다.)을 반환
        //연속적인 'gsd << xxx << xxx << xxx;'와 같은
        //명령을 사용할 수 있게 현재 객체를 다시 반환
        //하는 것이다.
	return *this;
}

//목표점에 도착하였는지를 점검
//target: 현재 마우스가 목표로 주행하는 지점
int SIMULATION::chktarget(void)
{
        if(mpos==target) return 1; //목표점에 도착
        return 0; //목표점에 도착하지 않음
}

//마우스의 위치에서 앞쪽 벽의 주소를 얻는다.
int SIMULATION::get_fw_pos(void)
{
	int _pos=mpos;

        //_pos를 마우스의 진해방향(mdir)로 이동
	moveposition(_pos, mdir);

	return _pos;
}

//마우스의 위치에서 왼쪽 벽의 주소를 얻는다.
int SIMULATION::get_lw_pos(void)
{
	int _pos=mpos;

	moveposition(_pos, (mdir-2)&0xf);

	return _pos;
}

//마우스의 위치에서 오른쪽 벽의 주소를 얻는다.
int SIMULATION::get_rw_pos(void)
{
	int _pos=mpos;

	moveposition(_pos, (mdir+2)&0xf);

	return _pos;
}

//벽정보를 시뮬레이션 map(simmap)로부터 얻어서
//벽정보 저장 map(wallmap)에 저장한다.
//실제 마우스에서 벽판별하는 루틴과 동일하다.
void SIMULATION::detectwall(void)
{
        int fw, lw, rw; //앞벽, 왼쪽벽, 오른쪽벽

        fw=get_fw_pos(); //앞벽의 주소
        lw=get_lw_pos(); //왼쪽벽의 주소
        rw=get_rw_pos(); //오른쪽벽의 주소

	wallmap[fw]=simmap[fw];
	wallmap[lw]=simmap[lw];
	wallmap[rw]=simmap[rw];

        //판별한 벽을 내부가 칠해진 벽으로 표시한다.
        //SOLID_WALL: 내부가 칠해진 벽
        //EMPTY_WALL: 내부가 빈 벽
	if(wallmap[fw]==YES_WALL) putwall(fw, SOLID_WALL);
	if(wallmap[lw]==YES_WALL) putwall(lw, SOLID_WALL);
	if(wallmap[rw]==YES_WALL) putwall(rw, SOLID_WALL);
}

//마우스가 현 위치에서 주행할 방향을 얻는다.
//tracepath() 함수 수행후 *tracer이 가지는 값이
//마우스가 다음 주행할 방향이다.
int SIMULATION::getcommand(void)
{
	return *tracer;
}

//목표점(미로의 가운데) 가장자리 8개 벽에 마우스가 도착하였는지
//체크하여 도착하였을 경우 목표점의 벽정보를 갱신하고, bestgoal
//다시말하여, 가장좋은 목표점을 설정한다.
//8개의 벽 가운데 1개만이 뚫려 있는 것이 대회의 규정이기 때문에
//불필요한 탐색을 줄이기 위해서이다.
void SIMULATION::chkgoalborder(void)
{
	if(mpos==252 || mpos==253 || mpos==255 || mpos==256 || mpos==286
		|| mpos==290 || mpos==321 || mpos==323) setbestgoal();
}

//가장좋은 목표점을 설정, 목표점의 8블록의 벽정보를 갱신
//8개의 벽 가운데 1개만이 뚫려 있는 것이 대회의 규정이기 때문에
//불필요한 탐색을 줄이기 위해서이다.
//목표점 가장자리 8블록: 252, 253, 255, 256, 286, 290, 321, 323
//simmap를 갱신하는 이유는 다음번 벽디텍트에서 simmap에서 wallmap
//로 잘못된 벽을 판별하는 것을 막기 위해서이다.
void SIMULATION::setbestgoal(void)
{
	wallmap[252]=simmap[252]=YES_WALL;
        wallmap[253]=simmap[253]=YES_WALL;
        wallmap[255]=simmap[255]=YES_WALL;
        wallmap[256]=simmap[256]=YES_WALL;
        wallmap[286]=simmap[286]=YES_WALL;
        wallmap[290]=simmap[290]=YES_WALL;
        wallmap[321]=simmap[321]=YES_WALL;
        wallmap[323]=simmap[323]=YES_WALL;

        //한 개의 뚫린 벽을 설정
        //마우스의 위치가 벽의 가장자리에 도착했다는 것은,
        //곧 그 벽만이 뚫려있다는 것을 나타낸다.
	wallmap[mpos]=simmap[mpos]=NO_WALL;

        //목표점의 벽을 채워진 벽으로 다시 표시
        //즉, 판별했다는 것을 의미한다.
	if(mpos!=252) putwall(252, SOLID_WALL);
	if(mpos!=253) putwall(253, SOLID_WALL);
	if(mpos!=255) putwall(255, SOLID_WALL);
	if(mpos!=256) putwall(256, SOLID_WALL);
	if(mpos!=286) putwall(286, SOLID_WALL);
	if(mpos!=290) putwall(290, SOLID_WALL);
	if(mpos!=321) putwall(321, SOLID_WALL);
	if(mpos!=323) putwall(323, SOLID_WALL);

        //목표점 내의 4벽을 '벽이 없음'으로 설정
	wallmap[254]=NO_WALL;
	wallmap[287]=NO_WALL;
	wallmap[288]=NO_WALL;
	wallmap[289]=NO_WALL;

        //goal에 가장 좋은 목표점을 저장하고,
        //현재의 목표점을 goal로 바꾼다.
        //또, 목표점 가장자리에 도착한 마우스를
        //진행방향으로 한블록 전진시키면 곧,
        //가장좋은 목표점을 찾을수 있다.

        //goal=현재의 마우스 위치(목표점 가장자리에 도착했을 경우)
	goal=mpos;

        //현재 마우스의 진행방향으로 한블록 이동
	moveposition(goal, mdir);

        //target=goal. 즉, 가장좋은 목표점
	target=goal;
}

//마우스의 위치, 방향 color의 색깔로 화면에 표시한다.
void SIMULATION::putposition(int color)
{
	char s[20];
	char *d[8]={"N", "NE", "E", "SE", "S", "SW", "W", "NW"};

	setcolor(color);

	sprintf(s, "position:%d", mpos);
	putmassage(23, s);

	sprintf(s, "direction:%s", d[mdir>>1]);
	putmassage(24, s);
}

//초기화면 메세지를 출력
void SIMULATION::titlemassage()
{
	setcolor(0xd);
	putmassage(0, "--------------");
	putmassage(1, "MICRO MOUSE");
	putmassage(2, "SIMULATOR V2.0");
	putmassage(3, "FOR GSD-II");
	putmassage(4, "--------------");

	setcolor(0xe);
	putmassage(6, "PROGRAMED BY");
	putmassage(7, "HYUN-JUN KIM");
	putmassage(8, "ELECTRONICS 94");
	putmassage(9, "HOSEO UNIVERSITY");

	setcolor(0xb);
	putmassage(11, "-----------------");
	putmassage(12, "     Using Key");
	putmassage(13, "-----------------");
	putmassage(14, "ESC: Stopping run");
	putmassage(15, "    &Exit program");
	putmassage(16, "R  : Running");
	putmassage(17, "L  : Loading maze");
	putmassage(18, "-----------------");
}

//현재의 주행 모드를 출력한다.
//xx차 주행(1차, 2차, ....)
//도착점(미로의 가운데 4블록), 출발점(미로의 좌측 최하단) 방향으로 주행
void SIMULATION::putracemode(int racing, int color)
{
	char s[20];

	setcolor(color);

	sprintf(s, "%dst running", (racing>>1)+1);
	putmassage(20, s);

	if(racing&1) {
		putmassage(21, "Going to HOME !!");
	} else {
		putmassage(21, "Going to GOAL !!");
	}
}

//메세지 출력을 위한 함수
void SIMULATION::putmassage(int ln, char *str)
{
	outtextxy(bw*16+win_x+10, win_y+10+10*ln, str);
}

